<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Snowgan</title><meta name="description" content="技术博客"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicons2.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://snowgan.com/atom.xml" title="Snowgan"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div class="wrap"><header><h1 class="blog-title">Snowgan</h1><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/21/How dose the Execution Context work in JS/" class="post-title-link">How dose the Execution Context work in JS</a></h2><div class="post-info">2017年6月21日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Advanced/" class="tag-link">Advanced</a><a href="/tags/Execution-Context/" class="tag-link">Execution Context</a></span></div><div class="post-content"><p>The Execution Context(normally called ‘EC’) is an abstract concept which defines how to execute the javascript code. We can simply think of a execution context as the environment js code is executed in. And there can be numbers of EC in our program.</p>
<h3 id="How-to-create-a-EC"><a href="#How-to-create-a-EC" class="headerlink" title="How to create a EC"></a>How to create a EC</h3><p>We can create a new EC by below three ways:</p>
<ol>
<li><strong>Global EC</strong>: Will create a global EC at the begin of running application, and only one global EC in the whole program;</li>
<li><strong>Function EC</strong>: Will create a function EC each time one function is called. And enter to this new execution environment to run the function code. When the function return back, will ends this new EC and return to previoue EC which called the function.</li>
<li><strong>eval()</strong>: Using eval function also will create a EC, but it’s better to not use eval.</li>
</ol></div><a href="/2017/06/21/How dose the Execution Context work in JS/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/07/Flexbox Table/" class="post-title-link">Flexbox Table</a></h2><div class="post-info">2017年3月7日<span class="tags-info"><a href="/tags/CSS/" class="tag-link">CSS</a><a href="/tags/flex/" class="tag-link">flex</a></span></div><div class="post-content"><p>Using CSS flex layout to create a table to replace the standard table markup.</p></div><a href="/2017/03/07/Flexbox Table/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/03/01/Flex Layout Basis/" class="post-title-link">Flex Layout Basis</a></h2><div class="post-info">2017年3月1日<span class="tags-info"><a href="/tags/CSS/" class="tag-link">CSS</a><a href="/tags/flex/" class="tag-link">flex</a></span></div><div class="post-content"><p>We can create a flexbox container by setting the <code>display</code> property to <strong>flex</strong> or <strong>inline-flex</strong>, and the direct children of the container will become <strong>flex item</strong>.</p>
<p>There are several property can be set on the container element.</p>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>Flexbox container have two axes: the main axis and the cross axis which indicate how the flex items place.</p>
<p><code>flex-direction</code> define the main axis direction.</p>
<p><code>flex-direction: row(defualt) | row-reverse | column | column-reverse;</code></p>
<p>The cross axis runs perpendicular to the main axis. The flex items will be placed according to the main axis direction.</p></div><a href="/2017/03/01/Flex Layout Basis/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/02/10/JavaScript Events/" class="post-title-link">JavaScript Events</a></h2><div class="post-info">2017年2月10日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Event/" class="tag-link">Event</a></span></div><div class="post-content"><p>Events plays the core role in Javascript to allow user to interact with the web application.</p>
<p>The basic work flow is:</p>
<ul>
<li>We register an event handler for specific event</li>
<li>JS detects the event takes place</li>
<li>Execute the event handler</li>
</ul></div><a href="/2017/02/10/JavaScript Events/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/26/Webpack Learning/" class="post-title-link">Webpack Learning</a></h2><div class="post-info">2017年1月26日<span class="tags-info"><a href="/tags/Webpack/" class="tag-link">Webpack</a><a href="/tags/Tool/" class="tag-link">Tool</a></span></div><div class="post-content"><h2 id="Why-use-webpack"><a href="#Why-use-webpack" class="headerlink" title="Why use webpack"></a>Why use webpack</h2><p>Why?</p>
<p>It’s the most popular build tool for javascript(According stars on github).</p>
<ul>
<li>Even though its configuration is too complex if we want a flexible build environment.</li>
<li>Even though it will bundle lots of wrapper code in final js file so it’s more overhead if our project is very simple.</li>
<li>Not to mention that there are many plugins to learn</li>
</ul>
<p>OK, that’s my hard points during my webpack trip.</p>
<p>But…</p></div><a href="/2017/01/26/Webpack Learning/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/11/Prototype/" class="post-title-link">Prototype in JS</a></h2><div class="post-info">2017年1月11日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Advanced/" class="tag-link">Advanced</a><a href="/tags/Prototype/" class="tag-link">Prototype</a></span></div><div class="post-content"><h3 id="object-prototype-and-prototype-chain"><a href="#object-prototype-and-prototype-chain" class="headerlink" title="object prototype and prototype chain"></a>object prototype and prototype chain</h3><p>Every object in Javascript has a prototype. And the prototype also is an object.</p>
<p>So we can get a prototype chain and the end of the chain links to <strong>Object.prototype</strong> whose prototype is null.</p>
<p>When trying to access a property of an object, will firstly find in object self. If cannot find it, will look up its prototype, and so on until find the property or the end of the prototype chain is reached.<br></div><a href="/2017/01/11/Prototype/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/01/05/Loop in JS/" class="post-title-link">Loop in JS</a></h2><div class="post-info">2017年1月5日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Grammer/" class="tag-link">Grammer</a></span></div><div class="post-content"><h3 id="For-loop"><a href="#For-loop" class="headerlink" title="For loop"></a>For loop</h3><pre><code class="js">for (let i = 0; i &lt; Things.length; i++) {
  Things[i]
}
</code></pre>
<p>The performance may be slow as the length property of Things will be accessed on each loop iteration.</p>
<p>A better way is to cache the length at initial phase, so we just access the length property once during the whole loop.</p>
<pre><code class="js">for (let i = 0. len = Things.length; i &lt; len; i++) {
  Things[i]
}
</code></pre>
<p>further micro-optimization:</p>
<p>cut the extra variable but reverse loop order</p>
<pre><code class="js">for (let i = Things.length; i--;) {
  Things[i]
}
</code></pre></div><a href="/2017/01/05/Loop in JS/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/16/React笔记/" class="post-title-link">React学习笔记</a></h2><div class="post-info">2016年12月16日<span class="tags-info"><a href="/tags/Basic/" class="tag-link">Basic</a><a href="/tags/React/" class="tag-link">React</a></span></div><div class="post-content"><h3 id="1-JSX语法"><a href="#1-JSX语法" class="headerlink" title="1. JSX语法"></a>1. JSX语法</h3><p>JSX是对JavaScript的拓展，采用HTML和JavaScript混写的语法，当遇到<strong>&lt;</strong>，JSX就当HTML解析，遇到<strong>{</strong>就当JavaScript解析</p>
<p>JSX的HTML写法与调用React.createElement(component, props, …children)函数的效果是一样的</p></div><a href="/2016/12/16/React笔记/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/09/JavaScript中的this笔记/" class="post-title-link">JavaScript中的this笔记</a></h2><div class="post-info">2016年12月9日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/this/" class="tag-link">this</a></span></div><div class="post-content"><h2 id="1-全局作用域下的this"><a href="#1-全局作用域下的this" class="headerlink" title="1. 全局作用域下的this"></a>1. 全局作用域下的this</h2><p>全局作用域下this的值由其js执行的宿主环境（浏览器、nodejs等）决定</p>
<p>在web浏览器中运行时，this与window对象等价，即<code>this === window</code></p>
<h2 id="2-函数作用域下的this"><a href="#2-函数作用域下的this" class="headerlink" title="2. 函数作用域下的this"></a>2. 函数作用域下的this</h2><p>函数作用域下this的值由其函数被调用的方式决定</p>
<p>函数调用方式有四种：</p>
<ol>
<li>作为对象方法被调用；</li>
<li>作为对象构造器，使用关键字new的形式被调用；</li>
<li>使用Function.prototype.apply()或Function.prototype.call()方法显式绑定this值</li>
<li>不属于以上任何一种，则作为普通函数被调用；</li>
</ol></div><a href="/2016/12/09/JavaScript中的this笔记/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/05/JavaScript函数笔记/" class="post-title-link">JavaScript函数笔记</a></h2><div class="post-info">2016年12月5日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Function/" class="tag-link">Function</a></span></div><div class="post-content"><p>和其他编程语言类似，JavaScript的函数也是用{}包裹的一个代码块，通过函数调用执行其方法体，能够进行值传参，并具有返回值，当没有显式声明返回值时，函数返回undefined。</p>
<h3 id="1-函数是第一类对象"><a href="#1-函数是第一类对象" class="headerlink" title="1. 函数是第一类对象"></a>1. 函数是第一类对象</h3><p>JS中的函数是一种对象类型，即是说可以当作对象来使用函数，相比其他对象类型，函数多了能被调用执行的功能。</p>
<p>函数和其他对象的使用对比：</p>
<pre><code class="js">// 赋值声明
var obj = {};
var func = function() {};

// 可添加属性
obj.name = &#39;Test&#39;;
func.name = &#39;Test&#39;;

// 作为数组元素或对象属性值
var testArr = [];
testArr.push({});
testArr.push(function() {});

var testObj = {};
testObj.item1 = {};
testObj.item2 = function() {};

// 作为函数参数
function testFunc1(arg) {};
testFunc1({});
testFunc1(function() {});

// 作为函数返回值
function testFunc2() {
  return {}
};
function testFunc3() {
  return function() {}
};
</code></pre></div><a href="/2016/12/05/JavaScript函数笔记/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/02/JavaScript数组笔记/" class="post-title-link">JavaScript数组笔记</a></h2><div class="post-info">2016年12月2日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Array/" class="tag-link">Array</a></span></div><div class="post-content"><p>数组的每一项可以保存任意类型的数据</p>
<h3 id="1-数组创建"><a href="#1-数组创建" class="headerlink" title="1. 数组创建"></a>1. 数组创建</h3><p>创建数组有两种方式（多使用第二种方式）：</p>
<ol>
<li><p>使用Array构造函数</p>
<p><code>var arr1 = new Array( &quot;hello&quot;, &quot;world&quot; );</code></p>
</li>
<li><p>使用字面量形式[]</p>
<p><code>var arr2 = [ &quot;hello&quot;, &quot;world&quot; ];</code></p>
</li>
</ol>
<pre><code class="js">// 数组类型判断（若Array的toString方法被重写，则不适用）：
function isArray(obj){
    return Object.prototype.toString.call(obj) === &#39;[object Array]&#39;;
}
</code></pre>
<h3 id="2-常用属性和方法"><a href="#2-常用属性和方法" class="headerlink" title="2. 常用属性和方法"></a>2. 常用属性和方法</h3><h4 id="2-1-length"><a href="#2-1-length" class="headerlink" title="2.1 .length"></a>2.1 .length</h4><pre><code class="js">// Length of an array
var myArray = [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot; ];
console.log( myArray.length ); // 3
// Empty array
myArray.length = 0;
console.log( myArray ); // myArray =&gt; []
// truncate array
myArray.length = 2;
console.log( myArray ); // myArray =&gt; [ &quot;hello&quot;, &quot;world&quot;]
myArray.length = 4;
console.log( myArray ); // myArray =&gt; [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot;, undefined]
</code></pre>
<h4 id="2-2-concat"><a href="#2-2-concat" class="headerlink" title="2.2 .concat()"></a>2.2 .concat()</h4><p>连接两个数组</p>
<pre><code class="js">var myArray = [ 2, 3, 4 ];
var myOtherArray = [ 5, 6, 7 ];
var wholeArray = myArray.concat( myOtherArray ); // [ 2, 3, 4, 5, 6, 7 ]
</code></pre></div><a href="/2016/12/02/JavaScript数组笔记/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/12/01/CSS模糊效果实践/" class="post-title-link">CSS模糊效果实践</a></h2><div class="post-info">2016年12月1日<span class="tags-info"><a href="/tags/CSS/" class="tag-link">CSS</a></span></div><div class="post-content"><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><pre><code class="html">&lt;!-- html --&gt;
&lt;div class=&quot;bgimg&quot;&gt;
  &lt;div class=&quot;blur&quot;&gt;模糊效果测试&lt;/div&gt;
&lt;/div&gt;

&lt;!-- css --&gt;
.bgimg{
    height: 500px;
    background-image: url(bgpic6.jpg);
    background-size: contain;
    background-repeat: no-repeat;
    overflow: hidden;
}
.blur {
    width: 200px;
    height: 200px;
    margin: 150px 250px;
    background-color: hsla(0,0%,100%,.4);
}
</code></pre>
<p><img src="/image/CSS模糊效果实践/001.png" alt="blur_test1"></p>
<p>这里使用hsla颜色值加透明度显示一个文字层的效果，但是并没有达到模糊的效果</p></div><a href="/2016/12/01/CSS模糊效果实践/" class="read-more">阅读全文>></a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/11/21/JavaScript基本类型/" class="post-title-link">JavaScript基本类型</a></h2><div class="post-info">2016年11月21日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/Basic/" class="tag-link">Basic</a></span></div><div class="post-content"><h3 id="1-变量和常量"><a href="#1-变量和常量" class="headerlink" title="1. 变量和常量"></a>1. 变量和常量</h3><p>JavaScript中的数据存储类型分为变量和常量（常量是es6新引入的），常量在声明初始化后就不能改变其值，变量则可任意改变。代码中尽可能使用常量以避免意外改变了值，除非业务逻辑明确需要一个变量</p>
<p>变量声明关键字： <strong>var</strong>, <strong>let(es6块级作用域申明)</strong></p>
<p>常量声明关键字： <strong>const(es6)</strong></p>
<blockquote>
<p>作为一种代码规范（而非必须），常量名使用大写字母和下划线组合</p>
</blockquote>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h3><p>JavaScript中的数据类型分为原生类型（primitive）和对象类型（object）</p>
<p>原生类型是不可变的，有六种类型：</p>
<ul>
<li>Undefined（唯一值undefined）</li>
<li>Null（唯一值null）</li>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol（es6）</li>
</ul></div><a href="/2016/11/21/JavaScript基本类型/" class="read-more">阅读全文>></a></article></li></ul></section><footer><div class="copyright"><p>© 2015 - 2018 <a href="http://snowgan.com">Snowgan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-90028164-1', 'auto');ga('send', 'pageview');</script></body></html>
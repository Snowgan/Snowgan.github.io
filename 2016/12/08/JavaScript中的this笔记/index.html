<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript中的this笔记 · Snowgan</title><meta name="description" content="JavaScript中的this笔记 - Snowgan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicons2.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://snowgan.com/atom.xml" title="Snowgan"></head><body><div class="wrap"><header><h1 class="blog-title">Snowgan</h1><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">分类</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">关于我</a></li></ul></header><section class="container"><div class="post"><div class="bread-crumb">/<a href="/categories/Front-End/" class="bread-crumb-item">Front-End</a>/<a href="/categories/Front-End/JavaScript/" class="bread-crumb-item">JavaScript</a></div><article class="post-block"><div class="post-toc"><div class="toc-title">目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-全局作用域下的this"><span class="toc-text">1. 全局作用域下的this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-函数作用域下的this"><span class="toc-text">2. 函数作用域下的this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-对象方法调用"><span class="toc-text">2.1 对象方法调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-对象构造器调用"><span class="toc-text">2.2 对象构造器调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-apply-amp-call-显式绑定"><span class="toc-text">2.3 apply()&call()显式绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-普通函数调用"><span class="toc-text">2.4 普通函数调用</span></a></li></ol></li></ol></div><h1 class="post-title">JavaScript中的this笔记</h1><div class="post-info">2016年12月8日<span class="tags-info"><a href="/tags/JavaScript/" class="tag-link">JavaScript</a><a href="/tags/this/" class="tag-link">this</a></span></div><div class="post-content"><h2 id="1-全局作用域下的this"><a href="#1-全局作用域下的this" class="headerlink" title="1. 全局作用域下的this"></a>1. 全局作用域下的this</h2><p>全局作用域下this的值由其js执行的宿主环境（浏览器、nodejs等）决定</p>
<p>在web浏览器中运行时，this与window对象等价，即<code>this === window</code></p>
<h2 id="2-函数作用域下的this"><a href="#2-函数作用域下的this" class="headerlink" title="2. 函数作用域下的this"></a>2. 函数作用域下的this</h2><p>函数作用域下this的值由其函数被调用的方式决定</p>
<p>函数调用方式有四种：</p>
<ol>
<li>作为对象方法被调用；</li>
<li>作为对象构造器，使用关键字new的形式被调用；</li>
<li>使用Function.prototype.apply()或Function.prototype.call()方法显式绑定this值</li>
<li>不属于以上任何一种，则作为普通函数被调用；</li>
</ol>
<a id="more"></a>
<h3 id="2-1-对象方法调用"><a href="#2-1-对象方法调用" class="headerlink" title="2.1 对象方法调用"></a>2.1 对象方法调用</h3><p>当对象的某一属性是一个函数，且通过该对象属性名调用函数时则视为对象方法调用，函数执行时的this指向<strong>对象本身</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Mike'</span>,</div><div class="line">  <span class="attr">func</span>: printName</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> obj2 = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Jenny'</span>,</div><div class="line">  <span class="attr">func</span>: printName</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> parent = &#123;</div><div class="line">  <span class="attr">child</span>: &#123;</div><div class="line">    <span class="attr">name</span>: <span class="string">'Anna'</span>,</div><div class="line">    <span class="attr">func</span>: printName</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">obj1.func(); <span class="comment">// 'Mike'  函数执行时的this === obj1</span></div><div class="line">obj2.func(); <span class="comment">// 'Jenny'  函数执行时的this === obj2</span></div><div class="line">parent.child.func(); <span class="comment">// 'Anna'  函数执行时的this === parent.child</span></div></pre></td></tr></table></figure>
<h3 id="2-2-对象构造器调用"><a href="#2-2-对象构造器调用" class="headerlink" title="2.2 对象构造器调用"></a>2.2 对象构造器调用</h3><p>在函数调用表达式前加上关键字new就完成了构造器调用<code>new Func()</code>，这个函数也被称作构造器，和其他面向对象语言类似，构造器主要用于构造一个实例对象，并完成一些初始化工作</p>
<p>构造器就是一个普通的函数，也可以直接跟()进行正常调用，当加上new之后，JS引擎的执行流程会发生变化，具体如下：</p>
<ol>
<li>新建一个空对象，其原型指向构造器的prototype属性</li>
<li>将this指向这个空对象</li>
<li>执行函数体</li>
<li>返回这个创建的对象，作为构造器调用的返回值</li>
</ol>
<p>所以在对象构造器调用方式下，this指向的是<strong>该构造器所创建的实例对象</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通常作为构造器的函数名首字母大写(代码规范)</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'Lee'</span>;</div><div class="line">  <span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Person();  <span class="comment">// 得到一个Person对象&#123; name: 'Lee', func: Function &#125;</span></div><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person();  <span class="comment">// p1.func() === p1;</span></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person();  <span class="comment">// p2.func() === p2;</span></div></pre></td></tr></table></figure>
<p>当构造器的函数体显式指定了返回值时，分两种情况：</p>
<ul>
<li>返回类型不是对象，构造器调用会忽略这条语句，返回创建的实例对象</li>
<li>返回类型是对象，构造器调用会执行这条语句，返回语句指定的对象</li>
</ul>
<h3 id="2-3-apply-amp-call-显式绑定"><a href="#2-3-apply-amp-call-显式绑定" class="headerlink" title="2.3 apply()&amp;call()显式绑定"></a>2.3 apply()&amp;call()显式绑定</h3><p>函数对象是Function构造器的一个实例，所以继承其原型上的方法，其中apply()和call()可以指定this和arguments的值</p>
<p><code>func.apply(thisVal[, argsArray])</code></p>
<p><code>func.call(thisVal[, args1, args2, ...])</code></p>
<p>两个方法的功能完全一样，区别在于apply传入由参数组成的数组或类数组对象，而call传入参数列表</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Mike'</span>,</div><div class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params">age</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">', '</span> + age);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj1.func(<span class="number">20</span>); <span class="comment">// 'Mike, 20'</span></div><div class="line">obj1.func.apply(&#123;<span class="attr">name</span>: <span class="string">'Jenny'</span>&#125;, [<span class="number">18</span>]); <span class="comment">// 'Jenny, 18'</span></div><div class="line">obj1.func.call(&#123;<span class="attr">name</span>: <span class="string">'Anna'</span>&#125;, <span class="number">10</span>); <span class="comment">// 'Anna, 10'</span></div></pre></td></tr></table></figure>
<h3 id="2-4-普通函数调用"><a href="#2-4-普通函数调用" class="headerlink" title="2.4 普通函数调用"></a>2.4 普通函数调用</h3><p>普通函数调用的表现形式主要有以下几种：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过函数名调用</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">func();</div><div class="line"></div><div class="line"><span class="comment">// 通过指向一个函数对象的变量名来调用</span></div><div class="line"><span class="keyword">var</span> funcVar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">funcVar();</div><div class="line"></div><div class="line"><span class="comment">// IIFE调用</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)();</div></pre></td></tr></table></figure>
<p>在非严格模式下this指向全局作用域下的this</p>
<p>在严格模式下this为undefined</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/12/05/JavaScript函数笔记/" class="next">下一篇: JavaScript函数笔记>></a></div><div id="disqus_thread"></div><script>var disqus_config = function () {
    this.page.url = 'http://snowgan.com/2016/12/08/JavaScript中的this笔记/';
    this.page.identifier = '2016/12/08/JavaScript中的this笔记/';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//' + 'snowgan' + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();</script><script id="dsq-count-scr" src="//snowgan.disqus.com/count.js" async></script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><div class="copyright"><p>© 2015 - 2017 <a href="http://snowgan.com">Snowgan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-90028164-1', 'auto');ga('send', 'pageview');</script></body></html>